[{"C:\\Projects\\dakan\\apps\\msearch\\src\\index.js":"1","C:\\Projects\\dakan\\apps\\msearch\\src\\main.js":"2","C:\\Projects\\dakan\\apps\\msearch\\src\\reportWebVitals.js":"3","C:\\Projects\\dakan\\apps\\msearch\\src\\pages\\PageNotFound.js":"4","C:\\Projects\\dakan\\apps\\msearch\\src\\pages\\SearchPage.js":"5","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\SearchBox.js":"6","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\Results.js":"7","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\Elasticsearch.js":"8","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\Facet.js":"9","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\ActiveFilters.js":"10","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\Listener.js":"11","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\SharedContextProvider.js":"12","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\Result.js":"13","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\utils.js":"14","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\CheckboxFacetView.js":"15","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\PanelFacetView.js":"16","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\getViewerProps.js":"17"},{"size":723,"mtime":1610382179377,"results":"18","hashOfConfig":"19"},{"size":3489,"mtime":1610382179385,"results":"20","hashOfConfig":"19"},{"size":364,"mtime":1610382179393,"results":"21","hashOfConfig":"19"},{"size":583,"mtime":1610382179388,"results":"22","hashOfConfig":"19"},{"size":8277,"mtime":1610383816719,"results":"23","hashOfConfig":"19"},{"size":2804,"mtime":1610387442492,"results":"24","hashOfConfig":"19"},{"size":3768,"mtime":1610382179424,"results":"25","hashOfConfig":"19"},{"size":1421,"mtime":1610382179361,"results":"26","hashOfConfig":"19"},{"size":3861,"mtime":1610382179412,"results":"27","hashOfConfig":"19"},{"size":3035,"mtime":1610382179359,"results":"28","hashOfConfig":"19"},{"size":9455,"mtime":1610382179362,"results":"29","hashOfConfig":"19"},{"size":456,"mtime":1610382179369,"results":"30","hashOfConfig":"19"},{"size":3837,"mtime":1610387296287,"results":"31","hashOfConfig":"19"},{"size":4003,"mtime":1610382179374,"results":"32","hashOfConfig":"19"},{"size":1685,"mtime":1610382179408,"results":"33","hashOfConfig":"19"},{"size":2115,"mtime":1610382179420,"results":"34","hashOfConfig":"19"},{"size":4261,"mtime":1610382179372,"results":"35","hashOfConfig":"19"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"dc0om8",{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"41","messages":"42","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"43","messages":"44","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"47","usedDeprecatedRules":"38"},{"filePath":"48","messages":"49","errorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"50"},{"filePath":"51","messages":"52","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"53","usedDeprecatedRules":"38"},{"filePath":"54","messages":"55","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"56","usedDeprecatedRules":"38"},{"filePath":"57","messages":"58","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"59","usedDeprecatedRules":"38"},{"filePath":"60","messages":"61","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"62","messages":"63","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"64","usedDeprecatedRules":"38"},{"filePath":"65","messages":"66","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"67","messages":"68","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"69","messages":"70","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71","usedDeprecatedRules":"38"},{"filePath":"72","messages":"73","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"38"},{"filePath":"77","messages":"78","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},"C:\\Projects\\dakan\\apps\\msearch\\src\\index.js",[],["79","80","81"],"C:\\Projects\\dakan\\apps\\msearch\\src\\main.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\reportWebVitals.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\pages\\PageNotFound.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\pages\\SearchPage.js",["82","83","84","85","86"],"/* eslint-disable jsx-a11y/no-onchange */\nimport React, { useState, useEffect } from 'react'\nimport { Panel, Layout, FilterIcon, Label } from '@dakan/ui'\nimport { Block } from 'baseui/block'\nimport { Accordion } from 'baseui/accordion'\nimport { Select } from 'baseui/select'\n\n\nimport Elasticsearch from '../components/Elasticsearch'\nimport Results from '../widgets/Results'\nimport Facet from '../widgets/Facet'\nimport SearchBox from '../widgets/SearchBox'\n\nimport qs from 'qs'\n\nimport env from '@beam-australia/react-env'\n\nconst server = env('ELASTIC_ENDPOINT')\nconst index = env('ELASTIC_INDEX')\nconst url = `${server}/${index}` \n\nconst SORTKEYS = [{'id':\"issued\", \"key\":\"issued\"},{\"id\":\"title\", \"key\":\"title.keyword\"}]\nconst SORTDIRECTION = [{\"id\":\"asc\", \"key\": \"asc\"},{\"id\": \"desc\", \"key\": \"desc\"}]\n\nconst SEARCHFIELDS = [\n    'title^18',\n    'title.search^6',\n    'decription^2',\n    'description.search',\n]\n\nfunction fromUrlQueryString(str) {\n    return new Map([\n        ...Object.entries(qs.parse(str.replace(/^\\?/, ''))).map(([k, v]) => {\n            try {\n                return [k, JSON.parse(v)]\n            } catch (e) {\n                return [k, v]\n            }\n        }),\n    ])\n}\n\nfunction toUrlQueryString(params) {\n    return qs.stringify(\n        Object.fromEntries(\n            new Map(\n                Array.from(params)\n                    .filter(([_k, v]) => (Array.isArray(v) ? v.length : v))\n                    .map(([k, v]) => [k, JSON.stringify(v)])\n            )\n        )\n    )\n}\n\nfunction SearchPage(props) {\n    const initialValues = fromUrlQueryString(\n        window.location.search.replace(/^\\?/, '')\n    )\n\n    function getSelectIndexPosition(elements, key) {\n        const pos = elements.findIndex(x => x.id === initialValues.get(key))\n        if (pos > -1) return [pos]\n        return [0]\n    }\n\n    const [queryString, setQueryString] = useState('')\n    const [values, setValues] = useState({})\n\n    const [sortOrderOption, setSortOrderOption] = useState(\n        getSelectIndexPosition(SORTDIRECTION, 'sortOrder')\n    )\n    const [sortKeyOption, setSortKeyOption] = useState(\n        getSelectIndexPosition(SORTKEYS,'sortKey')\n    )\n\n    const [sortOrder, setSortOrder] = useState(\n        initialValues.get('sortOrder') || 'title'\n    )\n    const [sortKey, setSortKey] = useState(\n        initialValues.get('sortKey') || 'asc'\n    )\n\n    const [sortQuery, setSortQuery] = useState([{ [sortKey]: { order: sortOrder } }]);\n    \n    useEffect(() => {\n        const selectedSortOrder = sortOrderOption[0]['key'] \n        const selectedSortKey = sortKeyOption[0]['key']\n        setSortOrder(selectedSortOrder)\n        setSortKey(selectedSortKey)\n\n        setSortQuery([{ [selectedSortKey]: { order: selectedSortOrder } }]);\n      }, [sortKeyOption, sortOrderOption]);\n\n    const onChange = (values) => {\n        if (values.size) {\n            values.set(\"sortKey\", sortKey) \n            values.set(\"sortOrder\",sortOrder ) \n        }\n        const q = toUrlQueryString(values)\n        if (q) {\n            window.history.replaceState('x', 'y', `?${q}`)\n        } \n    }\n\n    const [fields, setFields] = useState(SEARCHFIELDS)\n\n    function customQuery(query) {\n        if (!query) {\n            return {\n                match_all: {},\n            }\n        }\n        return {\n            bool: {\n                should: [\n                    {\n                        multi_match: {\n                            query,\n                            type: 'phrase',\n                            fields: fields,\n                        },\n                    },\n                    {\n                        multi_match: {\n                            query,\n                            type: 'phrase_prefix',\n                            fields: fields,\n                        },\n                    },\n                ],\n            },\n        }\n    }\n\n    const LeftSidebar = (props) => {\n        return (\n            <Block role=\"navigation\">\n                <Block display={['none', 'flex']} marginBottom=\"scale750\">\n                    <Block marginRight=\"scale200\">\n                        <FilterIcon size=\"24\" fill=\"#3E3832\" />\n                    </Block>\n                    <Label>Filter</Label>\n                </Block>\n\n                <Block>\n                    <Label>Format</Label>\n                    <Facet\n                        id=\"format\"\n                        fields={['format.keyword']}\n                        showFilter={false}\n                        initialValue={initialValues.get('format')}\n                    />\n                </Block>\n                <Block>\n                <Select  onChange={({value}) => setSortKeyOption(value)} value={sortKeyOption}\n                    options = {SORTKEYS}\n                    labelKey=\"id\"\n                    valueKey=\"key\"\n                >\n                </Select>\n                </Block>\n                <Block>\n                <Select onChange={({value}) => setSortOrderOption(value)} value={sortOrderOption}\n                    options = {SORTDIRECTION}\n                    labelKey=\"id\"\n                    valueKey=\"key\">\n                </Select>\n                </Block>\n            </Block>\n        )\n    }\n\n    const RightSidebar = (props) => {\n        return (\n            <Block role=\"contentinfo\">\n                <Facet\n                    title=\"Stikkord\"\n                    id=\"keyword\"\n                    fields={['keyword.keyword']}\n                    showFilter={false}\n                    type=\"panel\"\n                    initialValue={initialValues.get('keyword')}\n                />\n                <Facet\n                    title=\"Forfatter\"\n                    id=\"creator.name\"\n                    fields={['creator.name.keyword']}\n                    showFilter={false}\n                    type=\"panel\"\n                    initialValue={initialValues.get('creator.name')}\n                />\n                <Facet\n                    title=\"Opprinnelse\"\n                    id=\"provenance\"\n                    fields={['provenance.keyword']}\n                    showFilter={false}\n                    type=\"panel\"\n                    initialValue={initialValues.get('provenance')}\n                />\n            </Block>\n        )\n    }\n\n    const Content = (props) => {\n        const [panelExpanded, setPanelExpanded] = React.useState('')\n        return (\n            <React.Fragment>\n                <Block flex=\"1\" role=\"main\">\n                    <Block marginBottom=\"scale800\">\n                        <Block role=\"search\">\n                            <SearchBox\n                                id=\"term\"\n                                customQuery={customQuery}\n                                fields={fields}\n                                initialValue={initialValues.get('term')}\n                            />\n                        </Block>\n                    </Block>\n                    <Block display={['block', 'block', 'none']}>\n                        <Accordion\n                            onChange={(e) => setPanelExpanded(e.expanded[0])}\n                        >\n                            <Panel\n                                title=\"Filter\"\n                                isExpanded={panelExpanded === '0'}\n                            >\n                                <Block marginBottom=\"scale800\">\n                                    {LeftSidebar(props)}\n                                </Block>\n                            </Panel>\n                        </Accordion>\n                    </Block>\n                    <Results\n                        sort={sortQuery}\n                        id=\"result\"\n                        itemsPerPage=\"12\"\n                        initialPage={1}\n                        stats={(total) => <Label>{`Antall: ${total}`} </Label>}\n                    />\n                </Block>\n            </React.Fragment>\n        )\n    }\n\n    return (\n        <Elasticsearch\n            url={url}\n            onChange={(values) => onChange(values)}\n        >\n            <Layout\n                left={LeftSidebar(props)}\n                right={Content(props)}\n                options={RightSidebar(props)}\n            />\n        </Elasticsearch>\n    )\n}\n\nexport default SearchPage\n","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\SearchBox.js",["87","88","89","90","91","92"],"import React, { useState, useEffect, useRef } from 'react'\nimport { useSharedContext } from '../components/SharedContextProvider'\nimport { Spinner } from 'baseui/spinner'\nimport { Searchbox } from '@dakan/ui'\n\nfunction SearchBox({ customQuery, fields, id, initialValue, placeholder }) {\n    const [{ widgets }, dispatch] = useSharedContext()\n    const [value, setValue] = useState(initialValue || '')\n    const [searchTerm, setSearchTerm] = useState(initialValue || '')\n    const [isSearching, setIsSearching] = useState(false)\n    const intervalRef = useRef(null)\n\n    useEffect(() => {\n        if (searchTerm !== value) {\n            intervalRef.current = setTimeout(() => {\n                update(searchTerm)\n            }, 1000)\n        } else {\n            clearTimeout(intervalRef.current)\n        }\n        return () => clearTimeout(intervalRef.current)\n    }, [searchTerm])\n\n    // Update external query on mount.\n    useEffect(() => {\n        update(searchTerm)\n    }, [])\n\n    // If widget value was updated elsewhere (ex: from active filters deletion)\n    // We have to update and dispatch the component.\n    useEffect(() => {\n        widgets.get(id) && update(widgets.get(id).value)\n    }, [isValueReady()])\n\n    // Build a query from a value.\n    function queryFromValue(query) {\n        if (customQuery) {\n            return customQuery(query)\n        } else if (fields) {\n            return query\n                ? { multi_match: { query, type: 'phrase', fields } }\n                : { match_all: {} }\n        }\n        return { match_all: {} }\n    }\n\n    // This functions updates the current values, then dispatch\n    // the new widget properties to context.\n    // Called on mount and value change.\n    function update(v) {\n        setValue(v)\n        dispatch({\n            type: 'setWidget',\n            key: id,\n            needsQuery: true,\n            needsConfiguration: false,\n            isFacet: false,\n            wantResults: false,\n            query: queryFromValue(v),\n            value: v,\n            configuration: null,\n            result: null,\n        })\n    }\n\n    // Checks if widget value is the same as actual value.\n    function isValueReady() {\n        return !widgets.get(id) || widgets.get(id).value === value\n    }\n\n    // Destroy widget from context (remove from the list to unapply its effects)\n    useEffect(() => () => dispatch({ type: 'deleteWidget', key: id }), [])\n\n    return (\n            <Searchbox\n                value={searchTerm}\n                onChange={(e) => setSearchTerm(e.target.value)}\n                //onChange={(e) => update(e.target.value)}\n                placeholder={placeholder || 'søk…'}\n                startEnhancer={isSearching ? Spinner : null}\n                clearable\n            />\n    )\n}\n\nexport default SearchBox\n","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\Results.js",["93","94"],"import React, { useEffect, useState } from 'react'\nimport { useSharedContext } from '../components/SharedContextProvider'\nimport { Pagination } from 'baseui/pagination'\nimport ActiveFilters from '../components/ActiveFilters'\nimport { Block } from 'baseui/block'\nimport { Spinner } from 'baseui/spinner'\nimport Result from './Result'\n\n// Pagination, informations about results (like \"30 results\")\n// and size (number items per page) are customizable.\nfunction Results({\n    itemsPerPage,\n    initialPage = 1,\n    pagination,\n    stats,\n    items,\n    id,\n    sort,\n}) {\n    const [{ widgets }, dispatch] = useSharedContext()\n    const [initialization, setInitialization] = useState(true)\n    const [page, setPage] = useState(initialPage)\n    const widget = widgets.get(id)\n    const data =\n        widget && widget.result && widget.result.data ? widget.result.data : []\n    const total =\n        widget && widget.result && widget.result.total ? widget.result.total : 0\n    itemsPerPage = itemsPerPage || 10\n\n    useEffect(() => {\n        setPage(initialization ? initialPage : 1)\n        return () => setInitialization(false)\n    }, [initialPage, initialization, total.value])\n\n    // Update context with page (and itemsPerPage)\n    useEffect(() => {\n        dispatch({\n            type: 'setWidget',\n            key: id,\n            needsQuery: false,\n            needsConfiguration: true,\n            isFacet: false,\n            wantResults: true,\n            query: null,\n            value: null,\n            configuration: { itemsPerPage, page, sort },\n            result: data && total ? { data, total } : null,\n        })\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [page, sort])\n\n    // Destroy widget from context (remove from the list to unapply its effects)\n    useEffect(() => () => dispatch({ type: 'deleteWidget', key: id }), [])\n\n    const defaultPagination = () => (\n        <Pagination\n            numPages={Math.min(\n                Math.ceil(total.value / itemsPerPage),\n                10000 / itemsPerPage\n            )}\n            currentPage={page}\n            onPageChange={({ nextPage }) => {\n                setPage(Math.min(Math.max(nextPage, 1)))\n            }}\n        />\n    )\n\n    return (\n        <Block>\n            <Block marginTop=\"scale400\" marginBottom=\"scale600\" width=\"100%\">\n                {stats && total.value ? stats(total.value) : 'Ingen '}\n            </Block>\n            <ActiveFilters id=\"af\" />\n            <Block\n                marginTop=\"scale400\"\n                marginBottom=\"scale600\"\n                width=\"100%\"\n                overrides={{\n                    Block: {\n                        style: { borderBottom: '1px solid #efefef' },\n                    },\n                }}\n            />\n            <Block>\n                {data.map((item, index) => {\n                    return (\n                        <Result\n                            key={`result_${item._source.id}`}\n                            result={item._source}\n                            titleField=\"title\"\n                            handleChange\n                            even={index % 2}\n                        />\n                    )\n                })}\n                <Block marginTop=\"scale400\">\n                    {total.value > 1\n                        ? pagination\n                            ? pagination(\n                                  total.value,\n                                  itemsPerPage,\n                                  page,\n                                  setPage\n                              )\n                            : defaultPagination()\n                        : null}\n                </Block>\n            </Block>\n        </Block>\n    )\n}\n\nexport default Results\n","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\Elasticsearch.js",["95","96"],"import React, { useEffect } from 'react'\nimport { SharedContextProvider } from './SharedContextProvider'\nimport Listener from './Listener'\n\nexport default function ({ children, url, onChange, headers }) {\n    const initialState = {\n        url,\n        listenerEffect: null,\n        widgets: new Map(),\n        headers,\n    }\n\n    const reducer = (state, action) => {\n        const { widgets } = state\n        const widget = {\n            needsQuery: action.needsQuery,\n            needsConfiguration: action.needsConfiguration,\n            isFacet: action.isFacet,\n            wantResults: action.wantResults,\n            query: action.query,\n            value: action.value,\n            configuration: action.configuration,\n            result: action.result,\n        }\n        switch (action.type) {\n            case 'setWidget':\n                widgets.set(action.key, widget)\n                return { ...state, widgets }\n            case 'deleteWidget':\n                widgets.delete(action.key, widget)\n                return { ...state, widgets }\n            case 'setListenerEffect':\n                return { ...state, listenerEffect: action.value }\n            default:\n                return state\n        }\n    }\n\n    return (\n        <SharedContextProvider initialState={initialState} reducer={reducer}>\n            <Listener onChange={onChange}>{children}</Listener>\n        </SharedContextProvider>\n    )\n}\n","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\Facet.js",["97","98","99","100"],"import React, { useState, useEffect } from 'react'\nimport { toTermQueries } from '../components/utils'\nimport { useSharedContext } from '../components/SharedContextProvider'\nimport { CheckboxFacetView } from './CheckboxFacetView'\nimport { PanelFacetView } from './PanelFacetView'\n\nfunction Facet({\n    fields,\n    id,\n    initialValue,\n    seeMore,\n    placeholder,\n    showFilter = true,\n    filterValueModifier,\n    itemsPerBlock,\n    items,\n    type,\n    title,\n}) {\n    const [{ widgets }, dispatch] = useSharedContext()\n    // Current filter (search inside facet value).\n    const [filterValue, setFilterValue] = useState('')\n    // Number of itemns displayed in facet.\n    const [size, setSize] = useState(itemsPerBlock || 9)\n    // The actual selected items in facet.\n    const [value, setValue] = useState(initialValue || [])\n    // Data from internal queries (Elasticsearch queries are performed via Listener)\n    const { result } = widgets.get(id) || {}\n    const data = (result && result.data) || []\n    const total = (result && result.total) || 0\n\n    // Update widgets properties on state change.\n    useEffect(() => {\n        dispatch({\n            type: 'setWidget',\n            key: id,\n            needsQuery: true,\n            needsConfiguration: true,\n            isFacet: true,\n            wantResults: false,\n            query: { bool: { should: toTermQueries(fields, value) } },\n            value,\n            configuration: { size, filterValue, fields, filterValueModifier },\n            result: data && total ? { data, total } : null,\n        })\n    }, [size, filterValue, value])\n\n    // If widget value was updated elsewhere (ex: from active filters deletion)\n    // We have to update and dispatch the component.\n    useEffect(() => {\n        widgets.get(id) && setValue(widgets.get(id).value)\n    }, [isValueReady()])\n\n    // Destroy widget from context (remove from the list to unapply its effects)\n    useEffect(() => () => dispatch({ type: 'deleteWidget', key: id }), [])\n\n    // Checks if widget value is the same as actual value.\n    function isValueReady() {\n        return !widgets.get(id) || widgets.get(id).value === value\n    }\n\n    // On checkbox status change, add or remove current agg to selected\n    function handleChange(item, checked) {\n        const newValue = checked\n            ? [...new Set([...value, item.key])]\n            : value.filter((f) => f !== item.key)\n        setValue(newValue)\n    }\n\n    // Is current item checked?\n    function isChecked(item) {\n        return value.includes(item.key)\n    }\n\n    return (\n        <React.Fragment>\n            {type === 'panel' ? (\n                <PanelFacetView\n                    placeholder={placeholder}\n                    showFilter={showFilter}\n                    setFilterValue={setFilterValue}\n                    filterValue={filterValue}\n                    items={items}\n                    handleChange={handleChange}\n                    size={size}\n                    data={data}\n                    isChecked={isChecked}\n                    setSize={setSize}\n                    seeMore={seeMore}\n                    itemsPerBlock={itemsPerBlock}\n                    title={title}\n                />\n            ) : (\n                <CheckboxFacetView\n                    placeholder={placeholder}\n                    showFilter={showFilter}\n                    setFilterValue={setFilterValue}\n                    filterValue={filterValue}\n                    items={items}\n                    handleChange={handleChange}\n                    size={size}\n                    data={data}\n                    isChecked={isChecked}\n                    setSize={setSize}\n                    seeMore={seeMore}\n                    itemsPerBlock={itemsPerBlock}\n                />\n            )}\n        </React.Fragment>\n    )\n}\n\nexport default Facet\n","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\ActiveFilters.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\components\\Listener.js",["101","102","103"],"import React, { useEffect } from 'react'\nimport { useSharedContext } from './SharedContextProvider'\nimport { msearch, queryFrom, defer } from './utils'\n\n// This component needs to be cleaned.\nfunction Listener({ children, onChange }) {\n    const [\n        { url, listenerEffect, widgets, headers },\n        dispatch,\n    ] = useSharedContext()\n\n    // We need to prepare some data in each render.\n    // This needs to be done out of the effect function.\n    function widgetThat(key) {\n        return new Map([...widgets].filter(([, v]) => v[key]))\n    }\n    function mapFrom(key) {\n        return new Map(\n            [...widgets].filter(([, v]) => v[key]).map(([k, v]) => [k, v[key]])\n        )\n    }\n    const configurableWidgets = widgetThat('needsConfiguration')\n    const searchWidgets = widgetThat('needsQuery')\n    const queries = mapFrom('query')\n    const configurations = mapFrom('configuration')\n    const values = mapFrom('value')\n\n    useEffect(() => {\n        // Apply custom callback effect on every change, useful for query params.\n        if (onChange) {\n            // Add pages to params.\n            const pages = [...configurations]\n                .filter(([, v]) => v.page && v.page > 1)\n                .map(([k, v]) => [`${k}Page`, v.page])\n            // Run the change callback with all params.\n            onChange(new Map([...pages, ...values]))\n        }\n        // Run the deferred (thx algolia) listener effect.\n        listenerEffect && listenerEffect()\n    })\n\n    // Run effect on update for each change in queries or configuration.\n    useEffect(() => {\n        // If you are debugging and your debug path leads you here, you might\n        // check configurableWidgets and searchWidgets actually covers\n        // the whole list of components that are configurables and queryable.\n        const queriesReady = queries.size === searchWidgets.size\n        const configurationsReady =\n            configurations.size === configurableWidgets.size\n        if (queriesReady && configurationsReady) {\n            // The actual query to ES is deffered, to wait for all effects\n            // and context operations before running.\n            defer(() => {\n                dispatch({\n                    type: 'setListenerEffect',\n                    value: () => {\n                        const msearchData = []\n                        const facetWidgets = widgetThat('isFacet')\n                        const resultWidgets = widgetThat('wantResults')\n                        resultWidgets.forEach((r, id) => {\n                            const { itemsPerPage, page, sort } = r.configuration\n                            msearchData.push({\n                                query: {\n                                    query: queryFrom(queries),\n                                    size: itemsPerPage,\n                                    from: (page - 1) * itemsPerPage,\n                                    sort,\n                                },\n                                data: (result) => result.hits.hits,\n                                total: (result) => result.hits.total,\n                                id,\n                            })\n                        })\n\n                        // Fetch data for internal facet components.\n                        facetWidgets.forEach((f, id) => {\n                            const fields = f.configuration.fields\n                            const size = f.configuration.size\n                            const filterValue = f.configuration.filterValue\n                            const filterValueModifier =\n                                f.configuration.filterValueModifier\n\n                            // Get the aggs (elasticsearch queries) from fields\n                            // Dirtiest part, because we build a raw query from various params\n                            function aggsFromFields() {\n                                // Remove current query from queries list (do not react to self)\n                                function withoutOwnQueries() {\n                                    const q = new Map(queries)\n                                    q.delete(id)\n                                    return q\n                                }\n                                // Transform a single field to agg query\n                                function aggFromField(field) {\n                                    const t = {\n                                        field,\n                                        order: { _count: 'desc' },\n                                        size,\n                                    }\n                                    if (filterValue) {\n                                        t.include = !filterValueModifier\n                                            ? `.*${filterValue}.*`\n                                            : filterValueModifier(filterValue)\n                                    }\n                                    return { [field]: { terms: t } }\n                                }\n                                // Actually build the query from fields\n                                let result = {}\n                                fields.forEach((f) => {\n                                    result = { ...result, ...aggFromField(f) }\n                                })\n                                return {\n                                    query: queryFrom(withoutOwnQueries()),\n                                    size: 0,\n                                    aggs: result,\n                                }\n                            }\n                            msearchData.push({\n                                query: aggsFromFields(),\n                                data: (result) => {\n                                    // Merge aggs (if there is more than one for a facet),\n                                    // then remove duplicate and add doc_count (sum),\n                                    // then sort and slice to get only 10 first.\n                                    const map = new Map()\n                                    fields\n                                        .map(\n                                            (f) =>\n                                                result.aggregations[f].buckets\n                                        )\n                                        .reduce((a, b) => a.concat(b))\n                                        .forEach((i) => {\n                                            map.set(i.key, {\n                                                key: i.key,\n                                                doc_count: map.has(i.key)\n                                                    ? i.doc_count +\n                                                      map.get(i.key).doc_count\n                                                    : i.doc_count,\n                                            })\n                                        })\n                                    return [...map.values()]\n                                        .sort(\n                                            (x, y) => y.doc_count - x.doc_count\n                                        )\n                                        .slice(0, size)\n                                },\n                                total: (result) => result.hits.total,\n                                id: id,\n                            })\n                        })\n\n                        // Fetch the data.\n                        async function fetchData() {\n                            // Only if there is a query to run.\n                            if (msearchData.length) {\n                                const result = await msearch(\n                                    url,\n                                    msearchData,\n                                    headers\n                                )\n                                result.responses.forEach((response, key) => {\n                                    const widget = widgets.get(\n                                        msearchData[key].id\n                                    )\n                                    if (response.status !== 200) {\n                                        console.error(response.error.reason)\n                                        return\n                                    }\n                                    widget.result = {\n                                        data: msearchData[key].data(response),\n                                        total: msearchData[key].total(response),\n                                    }\n                                    // Update widget\n                                    dispatch({\n                                        type: 'setWidget',\n                                        key: msearchData[key].id,\n                                        ...widget,\n                                    })\n                                })\n                            }\n                        }\n                        fetchData()\n                        // Destroy the effect listener to avoid infinite loop!\n                        dispatch({ type: 'setListenerEffect', value: null })\n                    },\n                })\n            })\n        }\n    }, [\n        JSON.stringify(Array.from(queries)),\n        JSON.stringify(Array.from(configurations)),\n    ])\n\n    return <>{children}</>\n}\n\nexport default Listener\n","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\SharedContextProvider.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\Result.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\components\\utils.js",["104"],"import fetch from 'unfetch'\nimport qs from 'qs'\n\n// Search with msearch to elasticsearch instance\n// Todo reject.\nexport function msearch(url, msearchData, headers = {}) {\n    return new Promise(async (resolve, reject) => {\n        headers = {\n            ...{\n                Accept: 'application/json',\n                'Content-Type': 'application/x-ndjson',\n            },\n            ...headers,\n        }\n        const body = msearchData.reduce((acc, val) => {\n            const [p, q] = [{ preference: val.id }, val.query].map(\n                JSON.stringify\n            )\n            return `${acc}${p}\\n${q}\\n`\n        }, '')\n        const rawResponse = await fetch(`${url}`, {\n            method: 'POST',\n            headers,\n            body,\n        })\n        const response = await rawResponse.json()\n        resolve(response)\n    })\n}\n\nexport function getFilterValueDisplay(filterValue) {\n    let label = 'Ukjent'\n    if (!filterValue) return label\n    if (filterValue.hasOwnProperty('name')) label = filterValue.name\n    label = String(filterValue)\n\n    return getLocal(label)\n}\n\nexport function getLocal(label) {\n    if (label === 'datapackage') return 'Datapakke'\n    if (label === 'api' || label === 'API') return 'API'\n    if (label === 'begrep') return 'Begrep'\n    if (label === 'godkjent_begrep') return 'Godkjent begrep'\n    if (label === 'purpose') return 'Formål'\n    if (label === 'pii-type') return 'Opplysningstype'\n    if (label === 'kafka') return 'Datastrøm'\n    if (label === 'tabell') return 'Tabell'\n    if (label === 'kafka topic') return 'Kafka'\n    if (label === 'tableau') return 'Tableau'\n    if (label === 'keyword') return 'Stikkord'\n    if (label === 'format') return 'Format'\n    if (label === 'creator.name') return 'Forfatter'\n    if (label === 'provenance') return 'Opprinnelse'\n\n    return label\n}\n\nexport function logEvent(event, value, label) {\n    const eventProperty = {\n        filter: value.toLowerCase().replace(' ', '_'),\n        type: label.toLowerCase(),\n    }\n}\n\nexport function search(url, searchData, headers = {}) {\n    return new Promise(async (resolve, reject) => {\n        headers = {\n            ...{\n                Accept: '*/*',\n                'Content-Type': 'application/json; encoding=utf-8',\n            },\n            ...headers,\n        }\n        console.log('headers', headers)\n        const body = JSON.stringify(searchData.query)\n        console.log('body', JSON.stringify(body))\n        const rawResponse = await fetch(url, { method: 'POST', headers, body })\n        // TODO error handling\n        console.log('raw', rawResponse)\n        const response = await rawResponse.json()\n        console.log('response', response)\n        resolve(response)\n    })\n}\n\n// Build a query from a Map of queries\nexport function queryFrom(queries) {\n    return {\n        bool: {\n            must:\n                queries.size === 0\n                    ? { match_all: {} }\n                    : Array.from(queries.values()),\n        },\n    }\n}\n\n// Convert fields to term queries\nexport function toTermQueries(fields, selectedValues) {\n    const queries = []\n    for (let i in fields) {\n        for (let j in selectedValues) {\n            queries.push({ term: { [fields[i]]: selectedValues[j] } })\n        }\n    }\n    return queries\n}\n\nexport function fromUrlQueryString(str) {\n    return new Map([\n        ...Object.entries(qs.parse(str.replace(/^\\?/, ''))).map(([k, v]) => {\n            try {\n                return [k, JSON.parse(v)]\n            } catch (e) {\n                return [k, v]\n            }\n        }),\n    ])\n}\n\nexport function toUrlQueryString(params) {\n    return qs.stringify(\n        Object.fromEntries(\n            new Map(\n                Array.from(params)\n                    .filter(([_k, v]) => (Array.isArray(v) ? v.length : v))\n                    .map(([k, v]) => [k, JSON.stringify(v)])\n            )\n        )\n    )\n}\n\nconst resolved = Promise.resolve()\n\nexport const defer = (f) => {\n    resolved.then(f)\n}\n","C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\CheckboxFacetView.js",[],"C:\\Projects\\dakan\\apps\\msearch\\src\\widgets\\PanelFacetView.js",["105","106"],"import * as React from 'react'\nimport { Block } from 'baseui/block'\nimport { Button } from '@dakan/ui'\nimport { Tag } from '@dakan/ui'\nimport { KIND, SIZE } from 'baseui/button'\nimport { KIND as TAGKIND } from 'baseui/tag'\nimport { Card } from 'baseui/card'\n\nconst backgroundColor = 'lightBlue'\nconst borderColor = 'lightBlue'\n\nexport const PanelFacetView = ({\n    placeholder,\n    showFilter,\n    setFilterValue,\n    filterValue,\n    items,\n    handleChange,\n    size,\n    data,\n    isChecked,\n    setSize,\n    seeMore,\n    itemsPerBlock,\n    title,\n}) => {\n    const FacetCard = ({ data }) => {\n        if (!data) return null\n        return (\n            <Card title={title}>\n                <Block>\n                    {data.map((item) =>\n                        item.key ? (\n                            <Tag\n                                closeable={false}\n                                kind={TAGKIND.accent}\n                                onClick={(e) => {\n                                    handleChange(item, item)\n                                }}\n                            >\n                                {item.key}\n                            </Tag>\n                        ) : null\n                    )}\n                </Block>\n            </Card>\n        )\n    }\n\n    return (\n        <Block marginBottom=\"scale600\">\n            {showFilter ? (\n                <input\n                    value={filterValue}\n                    placeholder={placeholder || 'filter…'}\n                    type=\"text\"\n                    onChange={(e) => {\n                        setFilterValue(e.target.value)\n                    }}\n                />\n            ) : null}\n            {data && <FacetCard data={data} />}\n            {data.length === size ? (\n                <Button\n                    kind={KIND.minimal}\n                    size={SIZE.compact}\n                    onClick={() => setSize(size + (itemsPerBlock || 9))}\n                >\n                    {seeMore || 'se flere...'}\n                </Button>\n            ) : null}\n        </Block>\n    )\n}\n\nexport default PanelFacetView\n","C:\\Projects\\dakan\\apps\\msearch\\src\\components\\getViewerProps.js",[],{"ruleId":"107","replacedBy":"108"},{"ruleId":"109","replacedBy":"110"},{"ruleId":"111","replacedBy":"112"},{"ruleId":"113","severity":1,"message":"114","line":67,"column":12,"nodeType":"115","messageId":"116","endLine":67,"endColumn":23},{"ruleId":"113","severity":1,"message":"117","line":67,"column":25,"nodeType":"115","messageId":"116","endLine":67,"endColumn":39},{"ruleId":"113","severity":1,"message":"118","line":68,"column":12,"nodeType":"115","messageId":"116","endLine":68,"endColumn":18},{"ruleId":"113","severity":1,"message":"119","line":68,"column":20,"nodeType":"115","messageId":"116","endLine":68,"endColumn":29},{"ruleId":"113","severity":1,"message":"120","line":106,"column":20,"nodeType":"115","messageId":"116","endLine":106,"endColumn":29},{"ruleId":"113","severity":1,"message":"121","line":10,"column":25,"nodeType":"115","messageId":"116","endLine":10,"endColumn":39},{"ruleId":"122","severity":1,"message":"123","line":22,"column":8,"nodeType":"124","endLine":22,"endColumn":20,"suggestions":"125"},{"ruleId":"122","severity":1,"message":"126","line":27,"column":8,"nodeType":"124","endLine":27,"endColumn":10,"suggestions":"127"},{"ruleId":"122","severity":1,"message":"128","line":33,"column":8,"nodeType":"124","endLine":33,"endColumn":24,"suggestions":"129"},{"ruleId":"122","severity":1,"message":"130","line":33,"column":9,"nodeType":"131","endLine":33,"endColumn":23},{"ruleId":"122","severity":1,"message":"132","line":72,"column":72,"nodeType":"124","endLine":72,"endColumn":74,"suggestions":"133"},{"ruleId":"113","severity":1,"message":"134","line":6,"column":10,"nodeType":"115","messageId":"116","endLine":6,"endColumn":17},{"ruleId":"122","severity":1,"message":"132","line":53,"column":72,"nodeType":"124","endLine":53,"endColumn":74,"suggestions":"135"},{"ruleId":"113","severity":1,"message":"136","line":1,"column":17,"nodeType":"115","messageId":"116","endLine":1,"endColumn":26},{"ruleId":"137","severity":1,"message":"138","line":5,"column":1,"nodeType":"139","endLine":44,"endColumn":2},{"ruleId":"122","severity":1,"message":"140","line":46,"column":8,"nodeType":"124","endLine":46,"endColumn":34,"suggestions":"141"},{"ruleId":"122","severity":1,"message":"142","line":52,"column":8,"nodeType":"124","endLine":52,"endColumn":24,"suggestions":"143"},{"ruleId":"122","severity":1,"message":"130","line":52,"column":9,"nodeType":"131","endLine":52,"endColumn":23},{"ruleId":"122","severity":1,"message":"132","line":55,"column":72,"nodeType":"124","endLine":55,"endColumn":74,"suggestions":"144"},{"ruleId":"122","severity":1,"message":"145","line":187,"column":8,"nodeType":"124","endLine":190,"endColumn":6,"suggestions":"146"},{"ruleId":"122","severity":1,"message":"130","line":188,"column":9,"nodeType":"131","endLine":188,"endColumn":44},{"ruleId":"122","severity":1,"message":"130","line":189,"column":9,"nodeType":"131","endLine":189,"endColumn":51},{"ruleId":"113","severity":1,"message":"147","line":60,"column":11,"nodeType":"115","messageId":"116","endLine":60,"endColumn":24},{"ruleId":"113","severity":1,"message":"148","line":9,"column":7,"nodeType":"115","messageId":"116","endLine":9,"endColumn":22},{"ruleId":"113","severity":1,"message":"149","line":10,"column":7,"nodeType":"115","messageId":"116","endLine":10,"endColumn":18},"jsx-a11y/accessible-emoji",[],"no-native-reassign",["150"],"no-negated-in-lhs",["151"],"no-unused-vars","'queryString' is assigned a value but never used.","Identifier","unusedVar","'setQueryString' is assigned a value but never used.","'values' is assigned a value but never used.","'setValues' is assigned a value but never used.","'setFields' is assigned a value but never used.","'setIsSearching' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has missing dependencies: 'update' and 'value'. Either include them or remove the dependency array.","ArrayExpression",["152"],"React Hook useEffect has missing dependencies: 'searchTerm' and 'update'. Either include them or remove the dependency array.",["153"],"React Hook useEffect has missing dependencies: 'id', 'update', and 'widgets'. Either include them or remove the dependency array.",["154"],"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","CallExpression","React Hook useEffect has missing dependencies: 'dispatch' and 'id'. Either include them or remove the dependency array.",["155"],"'Spinner' is defined but never used.",["156"],"'useEffect' is defined but never used.","import/no-anonymous-default-export","Unexpected default export of anonymous function","ExportDefaultDeclaration","React Hook useEffect has missing dependencies: 'data', 'dispatch', 'fields', 'filterValueModifier', 'id', and 'total'. Either include them or remove the dependency array.",["157"],"React Hook useEffect has missing dependencies: 'id' and 'widgets'. Either include them or remove the dependency array. If 'setValue' needs the current value of 'id', you can also switch to useReducer instead of useState and read 'id' in the reducer.",["158"],["159"],"React Hook useEffect has missing dependencies: 'configurableWidgets.size', 'configurations.size', 'dispatch', 'headers', 'queries', 'searchWidgets.size', 'url', 'widgetThat', and 'widgets'. Either include them or remove the dependency array.",["160"],"'eventProperty' is assigned a value but never used.","'backgroundColor' is assigned a value but never used.","'borderColor' is assigned a value but never used.","no-global-assign","no-unsafe-negation",{"desc":"161","fix":"162"},{"desc":"163","fix":"164"},{"desc":"165","fix":"166"},{"desc":"167","fix":"168"},{"desc":"167","fix":"169"},{"desc":"170","fix":"171"},{"desc":"172","fix":"173"},{"desc":"167","fix":"174"},{"desc":"175","fix":"176"},"Update the dependencies array to be: [searchTerm, update, value]",{"range":"177","text":"178"},"Update the dependencies array to be: [searchTerm, update]",{"range":"179","text":"180"},"Update the dependencies array to be: [id, update, widgets]",{"range":"181","text":"182"},"Update the dependencies array to be: [dispatch, id]",{"range":"183","text":"184"},{"range":"185","text":"184"},"Update the dependencies array to be: [size, filterValue, value, dispatch, id, fields, filterValueModifier, data, total]",{"range":"186","text":"187"},"Update the dependencies array to be: [id, widgets]",{"range":"188","text":"189"},{"range":"190","text":"184"},"Update the dependencies array to be: [configurableWidgets.size, configurations.size, dispatch, headers, queries, searchWidgets.size, url, widgetThat, widgets]",{"range":"191","text":"192"},[868,880],"[searchTerm, update, value]",[978,980],"[searchTerm, update]",[1202,1218],"[id, update, widgets]",[2414,2416],"[dispatch, id]",[1865,1867],[1577,1603],"[size, filterValue, value, dispatch, id, fields, filterValueModifier, data, total]",[1827,1843],"[id, widgets]",[1998,2000],[9294,9398],"[configurableWidgets.size, configurations.size, dispatch, headers, queries, searchWidgets.size, url, widgetThat, widgets]"]